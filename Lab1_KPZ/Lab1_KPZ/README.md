# Опис дотримання принципів програмування в коді

У цьому проєкті я застосував основні принципи програмування для забезпечення чистоти коду, його простоти та зручності для підтримки. Нижче наведено пояснення, як я реалізував кожен з цих принципів:

---

## 1. **DRY (Don't Repeat Yourself)**

Принцип **DRY** означає, що я уникнув дублювання коду, що дозволяє зменшити обсяг коду і полегшує його підтримку. Я застосував його, об'єднавши повторювані логічні частини в окремі методи, які можна використовувати у різних місцях проєкту.

- Наприклад, у класі **Warehouse** я створив методи `AddProduct` і `ShipProduct`, які виконують операції з товарами, але не дублюють логіку, а використовують загальні допоміжні функції.

**Посилання на код**: [Warehouse.cs, рядки 21–34](./Models/Warehouse.cs#L21-L34)

---

## 2. **KISS (Keep It Simple, Stupid)**

Принцип **KISS** я реалізував шляхом спрощення логіки і структури класів. У кожному класі я втілював лише необхідний функціонал, що дозволяє програмі бути зрозумілою та легкою в підтримці. 

- Кожен клас відповідає лише за одну задачу, наприклад, клас **Product** відповідає тільки за товар, а клас **Money** — за грошові операції.

**Посилання на код**: [Product.cs, рядки 5–15](./Models/Product.cs#L5-L15)

---

## 3. **SOLID Principles**

### **S - Single Responsibility Principle (SRP)**

Принцип **SRP** полягає в тому, що кожен клас повинен мати лише одну відповідальність. Я чітко розподілив обов'язки між класами:
- **Money** — працює з грошима.
- **Product** — описує товар.
- **Warehouse** — управляє складом.
- **Reporting** — генерує звіти.

**Посилання на код**: [Money.cs, рядок 10](./Models/Money.cs#L10)

### **O - Open/Closed Principle (OCP)**

Мій код **відкритий для розширення**, але **закритий для змін**. Я можу додавати нові типи валют (USD, EUR) без необхідності змінювати вже існуючі класи, просто створивши нові підкласи.

**Посилання на код**: [Money.cs, рядки 15–20](./Models/Money.cs#L15-L20)

### **L - Liskov Substitution Principle (LSP)**

Принцип **LSP** забезпечує коректну роботу програми навіть при заміні базового класу на його підкласи. Наприклад, я можу замінити базовий клас **Money** на його підкласи, такі як **USD** або **EUR**, і програма працюватиме без помилок.

**Посилання на код**: [Money.cs, рядки 15–24](./Models/Money.cs#L15-L24)

### **I - Interface Segregation Principle (ISP)**

У даному проєкті я не використовував інтерфейси.

### **D - Dependency Inversion Principle (DIP)**

Принцип **DIP** ще не застосовувався у проекті.

---

## 4. **YAGNI (You Aren't Gonna Need It)**

Принцип **YAGNI** полягає в тому, що я не додаю функціональності, яка може бути не потрібною. Я створював тільки необхідні класи і методи, щоб задовольнити поточні вимоги проєкту. Не було створено зайвих абстракцій чи додаткових функцій, які не використовуються на даний момент.

**Посилання на код**: [Product.cs, рядки 5–15](./Models/Product.cs#L5-L15)

---

## 5. **Composition Over Inheritance**

Я використовував **композицію замість спадкування**, що дозволяє зберігати об'єкти одного класу (наприклад, об'єкти типу **Product**) у інших класах (наприклад, у **WarehouseItem**). Це дозволяє зменшити зв'язність між класами.

**Посилання на код**: [Warehouse.cs, рядки 5–14](./Models/Warehouse.cs#L5-L14)

---

## 6. **Program to Interfaces, not Implementations**

Цей принцип не застосовувався в проекті.

---

## 7. **Fail Fast**

Принцип **Fail Fast** я реалізував у методі **ShipProduct** класу **Warehouse**. Якщо на складі недостатньо товару для відвантаження, метод одразу викидає виключення, що дозволяє швидше виявити помилки.

**Посилання на код**: [Warehouse.cs, рядки 35–40](./Models/Warehouse.cs#L35-L40)